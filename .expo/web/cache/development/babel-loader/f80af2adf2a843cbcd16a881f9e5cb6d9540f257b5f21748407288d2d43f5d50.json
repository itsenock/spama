{"ast":null,"code":"import * as Notifications from \"expo-notifications\";\nimport * as Device from \"expo-device\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport { doc, updateDoc } from \"firebase/firestore\";\nimport { db } from \"../config/firebase\";\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: true,\n    shouldSetBadge: true\n  })\n});\nexport class NotificationService {\n  static async registerForPushNotifications() {\n    try {\n      if (!Device.isDevice) {\n        console.log(\"Must use physical device for Push Notifications\");\n        return null;\n      }\n      const {\n        status: existingStatus\n      } = await Notifications.getPermissionsAsync();\n      let finalStatus = existingStatus;\n      if (existingStatus !== \"granted\") {\n        const {\n          status\n        } = await Notifications.requestPermissionsAsync();\n        finalStatus = status;\n      }\n      if (finalStatus !== \"granted\") {\n        console.log(\"Failed to get push token for push notification!\");\n        return null;\n      }\n      const token = (await Notifications.getExpoPushTokenAsync()).data;\n      console.log(\"Push notification token:\", token);\n      if (Platform.OS === \"android\") {\n        Notifications.setNotificationChannelAsync(\"default\", {\n          name: \"default\",\n          importance: Notifications.AndroidImportance.MAX,\n          vibrationPattern: [0, 250, 250, 250],\n          lightColor: \"#FF231F7C\"\n        });\n      }\n      return token;\n    } catch (error) {\n      console.error(\"Error getting push token:\", error);\n      return null;\n    }\n  }\n  static async updateUserToken(userId, token) {\n    try {\n      await updateDoc(doc(db, \"users\", userId), {\n        fcmToken: token\n      });\n    } catch (error) {\n      console.error(\"Error updating FCM token:\", error);\n    }\n  }\n  static async showLocalNotification(title, body, data) {\n    try {\n      await Notifications.scheduleNotificationAsync({\n        content: {\n          title,\n          body,\n          data,\n          sound: \"default\"\n        },\n        trigger: null\n      });\n    } catch (error) {\n      console.error(\"Error showing local notification:\", error);\n    }\n  }\n  static addNotificationListener(callback) {\n    return Notifications.addNotificationReceivedListener(callback);\n  }\n  static addNotificationResponseListener(callback) {\n    return Notifications.addNotificationResponseReceivedListener(callback);\n  }\n  static async getPermissionStatus() {\n    const {\n      status\n    } = await Notifications.getPermissionsAsync();\n    return status;\n  }\n  static async cancelAllNotifications() {\n    await Notifications.cancelAllScheduledNotificationsAsync();\n  }\n  static async setBadgeCount(count) {\n    await Notifications.setBadgeCountAsync(count);\n  }\n  static async clearBadge() {\n    await Notifications.setBadgeCountAsync(0);\n  }\n  static async scheduleNotification(title, body, seconds, data) {\n    try {\n      await Notifications.scheduleNotificationAsync({\n        content: {\n          title,\n          body,\n          data,\n          sound: \"default\"\n        },\n        trigger: {\n          seconds\n        }\n      });\n    } catch (error) {\n      console.error(\"Error scheduling notification:\", error);\n    }\n  }\n  static handleNotification(notification, onMessageReceived) {\n    const {\n      data\n    } = notification.request.content;\n    if (data?.type === \"message\" && data?.chatId && data?.senderId) {\n      onMessageReceived(data.chatId, data.senderId);\n    }\n  }\n  static handleNotificationResponse(response, navigation) {\n    const {\n      data\n    } = response.notification.request.content;\n    if (data?.type === \"message\" && data?.chatId) {\n      navigation.navigate(\"Chat\", {\n        chatId: data.chatId,\n        chatName: data.chatName || \"Chat\",\n        avatar: data.avatar || \"ðŸ‘¤\"\n      });\n    }\n  }\n  static async sendPushNotification(targetToken, title, body, data) {\n    try {\n      const message = {\n        to: targetToken,\n        sound: \"default\",\n        title,\n        body,\n        data,\n        badge: 1\n      };\n      const response = await fetch(\"https://exp.host/--/api/v2/push/send\", {\n        method: \"POST\",\n        headers: {\n          Accept: \"application/json\",\n          \"Accept-encoding\": \"gzip, deflate\",\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(message)\n      });\n      const result = await response.json();\n      return result.data?.status === \"ok\";\n    } catch (error) {\n      console.error(\"Error sending push notification:\", error);\n      return false;\n    }\n  }\n  static async createNotificationCategories() {\n    if (Platform.OS === \"ios\") {\n      await Notifications.setNotificationCategoryAsync(\"message\", [{\n        identifier: \"reply\",\n        buttonTitle: \"Reply\",\n        options: {\n          opensAppToForeground: true\n        }\n      }, {\n        identifier: \"mark_read\",\n        buttonTitle: \"Mark as Read\",\n        options: {\n          opensAppToForeground: false\n        }\n      }]);\n    }\n  }\n  static formatMessageNotification(senderName, messageText, isGroup = false) {\n    return {\n      title: senderName,\n      body: isGroup ? `${senderName}: ${messageText}` : messageText,\n      data: {\n        type: \"message\",\n        timestamp: Date.now()\n      }\n    };\n  }\n  static formatCallNotification(callerName, callType) {\n    return {\n      title: `${callType === \"video\" ? \"Video\" : \"Audio\"} Call`,\n      body: `${callerName} is calling...`,\n      data: {\n        type: \"call\",\n        callType,\n        timestamp: Date.now()\n      }\n    };\n  }\n  static async getPendingNotifications() {\n    return await Notifications.getAllScheduledNotificationsAsync();\n  }\n  static async cancelNotification(notificationId) {\n    await Notifications.cancelScheduledNotificationAsync(notificationId);\n  }\n}","map":{"version":3,"names":["Notifications","Device","Platform","doc","updateDoc","db","setNotificationHandler","handleNotification","shouldShowAlert","shouldPlaySound","shouldSetBadge","NotificationService","registerForPushNotifications","isDevice","console","log","status","existingStatus","getPermissionsAsync","finalStatus","requestPermissionsAsync","token","getExpoPushTokenAsync","data","OS","setNotificationChannelAsync","name","importance","AndroidImportance","MAX","vibrationPattern","lightColor","error","updateUserToken","userId","fcmToken","showLocalNotification","title","body","scheduleNotificationAsync","content","sound","trigger","addNotificationListener","callback","addNotificationReceivedListener","addNotificationResponseListener","addNotificationResponseReceivedListener","getPermissionStatus","cancelAllNotifications","cancelAllScheduledNotificationsAsync","setBadgeCount","count","setBadgeCountAsync","clearBadge","scheduleNotification","seconds","notification","onMessageReceived","request","type","chatId","senderId","handleNotificationResponse","response","navigation","navigate","chatName","avatar","sendPushNotification","targetToken","message","to","badge","fetch","method","headers","Accept","JSON","stringify","result","json","createNotificationCategories","setNotificationCategoryAsync","identifier","buttonTitle","options","opensAppToForeground","formatMessageNotification","senderName","messageText","isGroup","timestamp","Date","now","formatCallNotification","callerName","callType","getPendingNotifications","getAllScheduledNotificationsAsync","cancelNotification","notificationId","cancelScheduledNotificationAsync"],"sources":["/project/sandbox/src/services/notificationService.ts"],"sourcesContent":["import * as Notifications from \"expo-notifications\";\nimport * as Device from \"expo-device\";\nimport { Platform } from \"react-native\";\nimport { doc, updateDoc } from \"firebase/firestore\";\nimport { db } from \"../config/firebase\";\n\n// Configure notification behavior\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: true,\n    shouldSetBadge: true,\n  }),\n});\n\nexport class NotificationService {\n  // Register for push notifications\n  static async registerForPushNotifications(): Promise<string | null> {\n    try {\n      if (!Device.isDevice) {\n        console.log(\"Must use physical device for Push Notifications\");\n        return null;\n      }\n\n      const { status: existingStatus } =\n        await Notifications.getPermissionsAsync();\n      let finalStatus = existingStatus;\n\n      if (existingStatus !== \"granted\") {\n        const { status } = await Notifications.requestPermissionsAsync();\n        finalStatus = status;\n      }\n\n      if (finalStatus !== \"granted\") {\n        console.log(\"Failed to get push token for push notification!\");\n        return null;\n      }\n\n      const token = (await Notifications.getExpoPushTokenAsync()).data;\n      console.log(\"Push notification token:\", token);\n\n      if (Platform.OS === \"android\") {\n        Notifications.setNotificationChannelAsync(\"default\", {\n          name: \"default\",\n          importance: Notifications.AndroidImportance.MAX,\n          vibrationPattern: [0, 250, 250, 250],\n          lightColor: \"#FF231F7C\",\n        });\n      }\n\n      return token;\n    } catch (error) {\n      console.error(\"Error getting push token:\", error);\n      return null;\n    }\n  }\n\n  // Update user's FCM token in Firestore\n  static async updateUserToken(userId: string, token: string): Promise<void> {\n    try {\n      await updateDoc(doc(db, \"users\", userId), {\n        fcmToken: token,\n      });\n    } catch (error) {\n      console.error(\"Error updating FCM token:\", error);\n    }\n  }\n\n  // Show local notification\n  static async showLocalNotification(\n    title: string,\n    body: string,\n    data?: any\n  ): Promise<void> {\n    try {\n      await Notifications.scheduleNotificationAsync({\n        content: {\n          title,\n          body,\n          data,\n          sound: \"default\",\n        },\n        trigger: null, // Show immediately\n      });\n    } catch (error) {\n      console.error(\"Error showing local notification:\", error);\n    }\n  }\n\n  // Listen for incoming notifications\n  static addNotificationListener(\n    callback: (notification: Notifications.Notification) => void\n  ) {\n    return Notifications.addNotificationReceivedListener(callback);\n  }\n\n  // Listen for notification responses (when user taps notification)\n  static addNotificationResponseListener(\n    callback: (response: Notifications.NotificationResponse) => void\n  ) {\n    return Notifications.addNotificationResponseReceivedListener(callback);\n  }\n\n  // Get notification permissions status\n  static async getPermissionStatus(): Promise<string> {\n    const { status } = await Notifications.getPermissionsAsync();\n    return status;\n  }\n\n  // Cancel all notifications\n  static async cancelAllNotifications(): Promise<void> {\n    await Notifications.cancelAllScheduledNotificationsAsync();\n  }\n\n  // Set badge count\n  static async setBadgeCount(count: number): Promise<void> {\n    await Notifications.setBadgeCountAsync(count);\n  }\n\n  // Clear badge\n  static async clearBadge(): Promise<void> {\n    await Notifications.setBadgeCountAsync(0);\n  }\n\n  // Schedule notification for later\n  static async scheduleNotification(\n    title: string,\n    body: string,\n    seconds: number,\n    data?: any\n  ): Promise<void> {\n    try {\n      await Notifications.scheduleNotificationAsync({\n        content: {\n          title,\n          body,\n          data,\n          sound: \"default\",\n        },\n        trigger: { seconds },\n      });\n    } catch (error) {\n      console.error(\"Error scheduling notification:\", error);\n    }\n  }\n\n  // Handle notification when app is in background/foreground\n  static handleNotification(\n    notification: Notifications.Notification,\n    onMessageReceived: (chatId: string, senderId: string) => void\n  ) {\n    const { data } = notification.request.content;\n\n    if (data?.type === \"message\" && data?.chatId && data?.senderId) {\n      onMessageReceived(data.chatId, data.senderId);\n    }\n  }\n\n  // Handle notification response when user taps notification\n  static handleNotificationResponse(\n    response: Notifications.NotificationResponse,\n    navigation: any\n  ) {\n    const { data } = response.notification.request.content;\n\n    if (data?.type === \"message\" && data?.chatId) {\n      // Navigate to chat screen\n      navigation.navigate(\"Chat\", {\n        chatId: data.chatId,\n        chatName: data.chatName || \"Chat\",\n        avatar: data.avatar || \"ðŸ‘¤\",\n      });\n    }\n  }\n\n  // Send push notification to specific user (would be handled by backend)\n  static async sendPushNotification(\n    targetToken: string,\n    title: string,\n    body: string,\n    data?: any\n  ): Promise<boolean> {\n    try {\n      // This would typically be done by your backend server\n      // Using Expo's push notification service\n      const message = {\n        to: targetToken,\n        sound: \"default\",\n        title,\n        body,\n        data,\n        badge: 1,\n      };\n\n      const response = await fetch(\"https://exp.host/--/api/v2/push/send\", {\n        method: \"POST\",\n        headers: {\n          Accept: \"application/json\",\n          \"Accept-encoding\": \"gzip, deflate\",\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(message),\n      });\n\n      const result = await response.json();\n      return result.data?.status === \"ok\";\n    } catch (error) {\n      console.error(\"Error sending push notification:\", error);\n      return false;\n    }\n  }\n\n  // Create notification categories (for iOS)\n  static async createNotificationCategories() {\n    if (Platform.OS === \"ios\") {\n      await Notifications.setNotificationCategoryAsync(\"message\", [\n        {\n          identifier: \"reply\",\n          buttonTitle: \"Reply\",\n          options: {\n            opensAppToForeground: true,\n          },\n        },\n        {\n          identifier: \"mark_read\",\n          buttonTitle: \"Mark as Read\",\n          options: {\n            opensAppToForeground: false,\n          },\n        },\n      ]);\n    }\n  }\n\n  // Format notification for message\n  static formatMessageNotification(\n    senderName: string,\n    messageText: string,\n    isGroup: boolean = false\n  ) {\n    return {\n      title: senderName,\n      body: isGroup ? `${senderName}: ${messageText}` : messageText,\n      data: {\n        type: \"message\",\n        timestamp: Date.now(),\n      },\n    };\n  }\n\n  // Format notification for call\n  static formatCallNotification(\n    callerName: string,\n    callType: \"audio\" | \"video\"\n  ) {\n    return {\n      title: `${callType === \"video\" ? \"Video\" : \"Audio\"} Call`,\n      body: `${callerName} is calling...`,\n      data: {\n        type: \"call\",\n        callType,\n        timestamp: Date.now(),\n      },\n    };\n  }\n\n  // Get all pending notifications\n  static async getPendingNotifications() {\n    return await Notifications.getAllScheduledNotificationsAsync();\n  }\n\n  // Cancel specific notification\n  static async cancelNotification(notificationId: string) {\n    await Notifications.cancelScheduledNotificationAsync(notificationId);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}