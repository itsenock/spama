{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport * as Notifications from \"expo-notifications\";\nimport * as Device from \"expo-device\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport { doc, updateDoc } from \"firebase/firestore\";\nimport { db } from \"../config/firebase\";\nNotifications.setNotificationHandler({\n  handleNotification: function () {\n    var _handleNotification = _asyncToGenerator(function* () {\n      return {\n        shouldShowAlert: true,\n        shouldPlaySound: true,\n        shouldSetBadge: true\n      };\n    });\n    function handleNotification() {\n      return _handleNotification.apply(this, arguments);\n    }\n    return handleNotification;\n  }()\n});\nexport var NotificationService = function () {\n  function NotificationService() {\n    _classCallCheck(this, NotificationService);\n  }\n  _createClass(NotificationService, null, [{\n    key: \"registerForPushNotifications\",\n    value: function () {\n      var _registerForPushNotifications = _asyncToGenerator(function* () {\n        try {\n          if (!Device.isDevice) {\n            console.log(\"Must use physical device for Push Notifications\");\n            return null;\n          }\n          var _yield$Notifications$ = yield Notifications.getPermissionsAsync(),\n            existingStatus = _yield$Notifications$.status;\n          var finalStatus = existingStatus;\n          if (existingStatus !== \"granted\") {\n            var _yield$Notifications$2 = yield Notifications.requestPermissionsAsync(),\n              status = _yield$Notifications$2.status;\n            finalStatus = status;\n          }\n          if (finalStatus !== \"granted\") {\n            console.log(\"Failed to get push token for push notification!\");\n            return null;\n          }\n          var token = (yield Notifications.getExpoPushTokenAsync()).data;\n          console.log(\"Push notification token:\", token);\n          if (Platform.OS === \"android\") {\n            Notifications.setNotificationChannelAsync(\"default\", {\n              name: \"default\",\n              importance: Notifications.AndroidImportance.MAX,\n              vibrationPattern: [0, 250, 250, 250],\n              lightColor: \"#FF231F7C\"\n            });\n          }\n          return token;\n        } catch (error) {\n          console.error(\"Error getting push token:\", error);\n          return null;\n        }\n      });\n      function registerForPushNotifications() {\n        return _registerForPushNotifications.apply(this, arguments);\n      }\n      return registerForPushNotifications;\n    }()\n  }, {\n    key: \"updateUserToken\",\n    value: function () {\n      var _updateUserToken = _asyncToGenerator(function* (userId, token) {\n        try {\n          yield updateDoc(doc(db, \"users\", userId), {\n            fcmToken: token\n          });\n        } catch (error) {\n          console.error(\"Error updating FCM token:\", error);\n        }\n      });\n      function updateUserToken(_x, _x2) {\n        return _updateUserToken.apply(this, arguments);\n      }\n      return updateUserToken;\n    }()\n  }, {\n    key: \"showLocalNotification\",\n    value: function () {\n      var _showLocalNotification = _asyncToGenerator(function* (title, body, data) {\n        try {\n          yield Notifications.scheduleNotificationAsync({\n            content: {\n              title: title,\n              body: body,\n              data: data,\n              sound: \"default\"\n            },\n            trigger: null\n          });\n        } catch (error) {\n          console.error(\"Error showing local notification:\", error);\n        }\n      });\n      function showLocalNotification(_x3, _x4, _x5) {\n        return _showLocalNotification.apply(this, arguments);\n      }\n      return showLocalNotification;\n    }()\n  }, {\n    key: \"addNotificationListener\",\n    value: function addNotificationListener(callback) {\n      return Notifications.addNotificationReceivedListener(callback);\n    }\n  }, {\n    key: \"addNotificationResponseListener\",\n    value: function addNotificationResponseListener(callback) {\n      return Notifications.addNotificationResponseReceivedListener(callback);\n    }\n  }, {\n    key: \"getPermissionStatus\",\n    value: function () {\n      var _getPermissionStatus = _asyncToGenerator(function* () {\n        var _yield$Notifications$3 = yield Notifications.getPermissionsAsync(),\n          status = _yield$Notifications$3.status;\n        return status;\n      });\n      function getPermissionStatus() {\n        return _getPermissionStatus.apply(this, arguments);\n      }\n      return getPermissionStatus;\n    }()\n  }, {\n    key: \"cancelAllNotifications\",\n    value: function () {\n      var _cancelAllNotifications = _asyncToGenerator(function* () {\n        yield Notifications.cancelAllScheduledNotificationsAsync();\n      });\n      function cancelAllNotifications() {\n        return _cancelAllNotifications.apply(this, arguments);\n      }\n      return cancelAllNotifications;\n    }()\n  }, {\n    key: \"setBadgeCount\",\n    value: function () {\n      var _setBadgeCount = _asyncToGenerator(function* (count) {\n        yield Notifications.setBadgeCountAsync(count);\n      });\n      function setBadgeCount(_x6) {\n        return _setBadgeCount.apply(this, arguments);\n      }\n      return setBadgeCount;\n    }()\n  }, {\n    key: \"clearBadge\",\n    value: function () {\n      var _clearBadge = _asyncToGenerator(function* () {\n        yield Notifications.setBadgeCountAsync(0);\n      });\n      function clearBadge() {\n        return _clearBadge.apply(this, arguments);\n      }\n      return clearBadge;\n    }()\n  }, {\n    key: \"scheduleNotification\",\n    value: function () {\n      var _scheduleNotification = _asyncToGenerator(function* (title, body, seconds, data) {\n        try {\n          yield Notifications.scheduleNotificationAsync({\n            content: {\n              title: title,\n              body: body,\n              data: data,\n              sound: \"default\"\n            },\n            trigger: {\n              seconds: seconds\n            }\n          });\n        } catch (error) {\n          console.error(\"Error scheduling notification:\", error);\n        }\n      });\n      function scheduleNotification(_x7, _x8, _x9, _x10) {\n        return _scheduleNotification.apply(this, arguments);\n      }\n      return scheduleNotification;\n    }()\n  }, {\n    key: \"handleNotification\",\n    value: function handleNotification(notification, onMessageReceived) {\n      var data = notification.request.content.data;\n      if ((data == null ? void 0 : data.type) === \"message\" && data != null && data.chatId && data != null && data.senderId) {\n        onMessageReceived(data.chatId, data.senderId);\n      }\n    }\n  }, {\n    key: \"handleNotificationResponse\",\n    value: function handleNotificationResponse(response, navigation) {\n      var data = response.notification.request.content.data;\n      if ((data == null ? void 0 : data.type) === \"message\" && data != null && data.chatId) {\n        navigation.navigate(\"Chat\", {\n          chatId: data.chatId,\n          chatName: data.chatName || \"Chat\",\n          avatar: data.avatar || \"ğŸ‘¤\"\n        });\n      }\n    }\n  }, {\n    key: \"sendPushNotification\",\n    value: function () {\n      var _sendPushNotification = _asyncToGenerator(function* (targetToken, title, body, data) {\n        try {\n          var _result$data;\n          var message = {\n            to: targetToken,\n            sound: \"default\",\n            title: title,\n            body: body,\n            data: data,\n            badge: 1\n          };\n          var _response = yield fetch(\"https://exp.host/--/api/v2/push/send\", {\n            method: \"POST\",\n            headers: {\n              Accept: \"application/json\",\n              \"Accept-encoding\": \"gzip, deflate\",\n              \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(message)\n          });\n          var result = yield _response.json();\n          return ((_result$data = result.data) == null ? void 0 : _result$data.status) === \"ok\";\n        } catch (error) {\n          console.error(\"Error sending push notification:\", error);\n          return false;\n        }\n      });\n      function sendPushNotification(_x11, _x12, _x13, _x14) {\n        return _sendPushNotification.apply(this, arguments);\n      }\n      return sendPushNotification;\n    }()\n  }, {\n    key: \"createNotificationCategories\",\n    value: function () {\n      var _createNotificationCategories = _asyncToGenerator(function* () {\n        if (Platform.OS === \"ios\") {\n          yield Notifications.setNotificationCategoryAsync(\"message\", [{\n            identifier: \"reply\",\n            buttonTitle: \"Reply\",\n            options: {\n              opensAppToForeground: true\n            }\n          }, {\n            identifier: \"mark_read\",\n            buttonTitle: \"Mark as Read\",\n            options: {\n              opensAppToForeground: false\n            }\n          }]);\n        }\n      });\n      function createNotificationCategories() {\n        return _createNotificationCategories.apply(this, arguments);\n      }\n      return createNotificationCategories;\n    }()\n  }, {\n    key: \"formatMessageNotification\",\n    value: function formatMessageNotification(senderName, messageText) {\n      var isGroup = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      return {\n        title: senderName,\n        body: isGroup ? `${senderName}: ${messageText}` : messageText,\n        data: {\n          type: \"message\",\n          timestamp: Date.now()\n        }\n      };\n    }\n  }, {\n    key: \"formatCallNotification\",\n    value: function formatCallNotification(callerName, callType) {\n      return {\n        title: `${callType === \"video\" ? \"Video\" : \"Audio\"} Call`,\n        body: `${callerName} is calling...`,\n        data: {\n          type: \"call\",\n          callType: callType,\n          timestamp: Date.now()\n        }\n      };\n    }\n  }, {\n    key: \"getPendingNotifications\",\n    value: function () {\n      var _getPendingNotifications = _asyncToGenerator(function* () {\n        return yield Notifications.getAllScheduledNotificationsAsync();\n      });\n      function getPendingNotifications() {\n        return _getPendingNotifications.apply(this, arguments);\n      }\n      return getPendingNotifications;\n    }()\n  }, {\n    key: \"cancelNotification\",\n    value: function () {\n      var _cancelNotification = _asyncToGenerator(function* (notificationId) {\n        yield Notifications.cancelScheduledNotificationAsync(notificationId);\n      });\n      function cancelNotification(_x15) {\n        return _cancelNotification.apply(this, arguments);\n      }\n      return cancelNotification;\n    }()\n  }]);\n  return NotificationService;\n}();","map":{"version":3,"names":["Notifications","Device","Platform","doc","updateDoc","db","setNotificationHandler","handleNotification","_handleNotification","_asyncToGenerator","shouldShowAlert","shouldPlaySound","shouldSetBadge","apply","arguments","NotificationService","_classCallCheck","_createClass","key","value","_registerForPushNotifications","isDevice","console","log","_yield$Notifications$","getPermissionsAsync","existingStatus","status","finalStatus","_yield$Notifications$2","requestPermissionsAsync","token","getExpoPushTokenAsync","data","OS","setNotificationChannelAsync","name","importance","AndroidImportance","MAX","vibrationPattern","lightColor","error","registerForPushNotifications","_updateUserToken","userId","fcmToken","updateUserToken","_x","_x2","_showLocalNotification","title","body","scheduleNotificationAsync","content","sound","trigger","showLocalNotification","_x3","_x4","_x5","addNotificationListener","callback","addNotificationReceivedListener","addNotificationResponseListener","addNotificationResponseReceivedListener","_getPermissionStatus","_yield$Notifications$3","getPermissionStatus","_cancelAllNotifications","cancelAllScheduledNotificationsAsync","cancelAllNotifications","_setBadgeCount","count","setBadgeCountAsync","setBadgeCount","_x6","_clearBadge","clearBadge","_scheduleNotification","seconds","scheduleNotification","_x7","_x8","_x9","_x10","notification","onMessageReceived","request","type","chatId","senderId","handleNotificationResponse","response","navigation","navigate","chatName","avatar","_sendPushNotification","targetToken","_result$data","message","to","badge","fetch","method","headers","Accept","JSON","stringify","result","json","sendPushNotification","_x11","_x12","_x13","_x14","_createNotificationCategories","setNotificationCategoryAsync","identifier","buttonTitle","options","opensAppToForeground","createNotificationCategories","formatMessageNotification","senderName","messageText","isGroup","length","undefined","timestamp","Date","now","formatCallNotification","callerName","callType","_getPendingNotifications","getAllScheduledNotificationsAsync","getPendingNotifications","_cancelNotification","notificationId","cancelScheduledNotificationAsync","cancelNotification","_x15"],"sources":["/project/workspace/src/services/notificationService.ts"],"sourcesContent":["import * as Notifications from \"expo-notifications\";\nimport * as Device from \"expo-device\";\nimport { Platform } from \"react-native\";\nimport { doc, updateDoc } from \"firebase/firestore\";\nimport { db } from \"../config/firebase\";\n\n// Configure notification behavior\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: true,\n    shouldSetBadge: true,\n  }),\n});\n\nexport class NotificationService {\n  // Register for push notifications\n  static async registerForPushNotifications(): Promise<string | null> {\n    try {\n      if (!Device.isDevice) {\n        console.log(\"Must use physical device for Push Notifications\");\n        return null;\n      }\n\n      const { status: existingStatus } =\n        await Notifications.getPermissionsAsync();\n      let finalStatus = existingStatus;\n\n      if (existingStatus !== \"granted\") {\n        const { status } = await Notifications.requestPermissionsAsync();\n        finalStatus = status;\n      }\n\n      if (finalStatus !== \"granted\") {\n        console.log(\"Failed to get push token for push notification!\");\n        return null;\n      }\n\n      const token = (await Notifications.getExpoPushTokenAsync()).data;\n      console.log(\"Push notification token:\", token);\n\n      if (Platform.OS === \"android\") {\n        Notifications.setNotificationChannelAsync(\"default\", {\n          name: \"default\",\n          importance: Notifications.AndroidImportance.MAX,\n          vibrationPattern: [0, 250, 250, 250],\n          lightColor: \"#FF231F7C\",\n        });\n      }\n\n      return token;\n    } catch (error) {\n      console.error(\"Error getting push token:\", error);\n      return null;\n    }\n  }\n\n  // Update user's FCM token in Firestore\n  static async updateUserToken(userId: string, token: string): Promise<void> {\n    try {\n      await updateDoc(doc(db, \"users\", userId), {\n        fcmToken: token,\n      });\n    } catch (error) {\n      console.error(\"Error updating FCM token:\", error);\n    }\n  }\n\n  // Show local notification\n  static async showLocalNotification(\n    title: string,\n    body: string,\n    data?: any\n  ): Promise<void> {\n    try {\n      await Notifications.scheduleNotificationAsync({\n        content: {\n          title,\n          body,\n          data,\n          sound: \"default\",\n        },\n        trigger: null, // Show immediately\n      });\n    } catch (error) {\n      console.error(\"Error showing local notification:\", error);\n    }\n  }\n\n  // Listen for incoming notifications\n  static addNotificationListener(\n    callback: (notification: Notifications.Notification) => void\n  ) {\n    return Notifications.addNotificationReceivedListener(callback);\n  }\n\n  // Listen for notification responses (when user taps notification)\n  static addNotificationResponseListener(\n    callback: (response: Notifications.NotificationResponse) => void\n  ) {\n    return Notifications.addNotificationResponseReceivedListener(callback);\n  }\n\n  // Get notification permissions status\n  static async getPermissionStatus(): Promise<string> {\n    const { status } = await Notifications.getPermissionsAsync();\n    return status;\n  }\n\n  // Cancel all notifications\n  static async cancelAllNotifications(): Promise<void> {\n    await Notifications.cancelAllScheduledNotificationsAsync();\n  }\n\n  // Set badge count\n  static async setBadgeCount(count: number): Promise<void> {\n    await Notifications.setBadgeCountAsync(count);\n  }\n\n  // Clear badge\n  static async clearBadge(): Promise<void> {\n    await Notifications.setBadgeCountAsync(0);\n  }\n\n  // Schedule notification for later\n  static async scheduleNotification(\n    title: string,\n    body: string,\n    seconds: number,\n    data?: any\n  ): Promise<void> {\n    try {\n      await Notifications.scheduleNotificationAsync({\n        content: {\n          title,\n          body,\n          data,\n          sound: \"default\",\n        },\n        trigger: { seconds },\n      });\n    } catch (error) {\n      console.error(\"Error scheduling notification:\", error);\n    }\n  }\n\n  // Handle notification when app is in background/foreground\n  static handleNotification(\n    notification: Notifications.Notification,\n    onMessageReceived: (chatId: string, senderId: string) => void\n  ) {\n    const { data } = notification.request.content;\n\n    if (data?.type === \"message\" && data?.chatId && data?.senderId) {\n      onMessageReceived(data.chatId, data.senderId);\n    }\n  }\n\n  // Handle notification response when user taps notification\n  static handleNotificationResponse(\n    response: Notifications.NotificationResponse,\n    navigation: any\n  ) {\n    const { data } = response.notification.request.content;\n\n    if (data?.type === \"message\" && data?.chatId) {\n      // Navigate to chat screen\n      navigation.navigate(\"Chat\", {\n        chatId: data.chatId,\n        chatName: data.chatName || \"Chat\",\n        avatar: data.avatar || \"ğŸ‘¤\",\n      });\n    }\n  }\n\n  // Send push notification to specific user (would be handled by backend)\n  static async sendPushNotification(\n    targetToken: string,\n    title: string,\n    body: string,\n    data?: any\n  ): Promise<boolean> {\n    try {\n      // This would typically be done by your backend server\n      // Using Expo's push notification service\n      const message = {\n        to: targetToken,\n        sound: \"default\",\n        title,\n        body,\n        data,\n        badge: 1,\n      };\n\n      const response = await fetch(\"https://exp.host/--/api/v2/push/send\", {\n        method: \"POST\",\n        headers: {\n          Accept: \"application/json\",\n          \"Accept-encoding\": \"gzip, deflate\",\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(message),\n      });\n\n      const result = await response.json();\n      return result.data?.status === \"ok\";\n    } catch (error) {\n      console.error(\"Error sending push notification:\", error);\n      return false;\n    }\n  }\n\n  // Create notification categories (for iOS)\n  static async createNotificationCategories() {\n    if (Platform.OS === \"ios\") {\n      await Notifications.setNotificationCategoryAsync(\"message\", [\n        {\n          identifier: \"reply\",\n          buttonTitle: \"Reply\",\n          options: {\n            opensAppToForeground: true,\n          },\n        },\n        {\n          identifier: \"mark_read\",\n          buttonTitle: \"Mark as Read\",\n          options: {\n            opensAppToForeground: false,\n          },\n        },\n      ]);\n    }\n  }\n\n  // Format notification for message\n  static formatMessageNotification(\n    senderName: string,\n    messageText: string,\n    isGroup: boolean = false\n  ) {\n    return {\n      title: senderName,\n      body: isGroup ? `${senderName}: ${messageText}` : messageText,\n      data: {\n        type: \"message\",\n        timestamp: Date.now(),\n      },\n    };\n  }\n\n  // Format notification for call\n  static formatCallNotification(\n    callerName: string,\n    callType: \"audio\" | \"video\"\n  ) {\n    return {\n      title: `${callType === \"video\" ? \"Video\" : \"Audio\"} Call`,\n      body: `${callerName} is calling...`,\n      data: {\n        type: \"call\",\n        callType,\n        timestamp: Date.now(),\n      },\n    };\n  }\n\n  // Get all pending notifications\n  static async getPendingNotifications() {\n    return await Notifications.getAllScheduledNotificationsAsync();\n  }\n\n  // Cancel specific notification\n  static async cancelNotification(notificationId: string) {\n    await Notifications.cancelScheduledNotificationAsync(notificationId);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}